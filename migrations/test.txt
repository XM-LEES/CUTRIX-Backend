-- Initial schema for laying-up domain using a dedicated schema
-- Adopt concise names under the `production` schema and keep `Workers` in public.

BEGIN;

-- Create domain schema
CREATE SCHEMA IF NOT EXISTS production;

-- Users (shared across domains)
CREATE TABLE IF NOT EXISTS public.users (
    user_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255),
    role VARCHAR(20) NOT NULL DEFAULT 'worker' CHECK (role IN ('admin', 'manager', 'worker', 'pattern_maker')),
    is_active BOOLEAN NOT NULL DEFAULT true,
    user_group VARCHAR(50),
    note VARCHAR(255)
);

-- Orders (core record)
CREATE TABLE IF NOT EXISTS production.orders (
    order_id SERIAL PRIMARY KEY,
    order_number VARCHAR(100) NOT NULL UNIQUE,
    style_number VARCHAR(50) NOT NULL,
    customer_name VARCHAR(100),
    note TEXT,
    order_start_date TIMESTAMP,                                 -- when order is placed
    order_finish_date TIMESTAMP,                                -- when order is finished
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,    -- when order is created in CUTRIX system
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP     -- when order is updated in CUTRIX system
);

-- Order items (color-size-quantity)
CREATE TABLE IF NOT EXISTS production.order_items (
    item_id SERIAL PRIMARY KEY,
    order_id INT NOT NULL REFERENCES production.orders(order_id) ON DELETE CASCADE,
    color VARCHAR(50) NOT NULL,
    size VARCHAR(30) NOT NULL,
    quantity INT NOT NULL CHECK (quantity > 0),
    UNIQUE(order_id, color, size)
);

-- Orders updates: allow updating note and order_finish_date; auto-update updated_at
CREATE OR REPLACE FUNCTION production.guard_orders_update()
RETURNS TRIGGER AS $$
BEGIN
    -- Allow only updating note and order_finish_date; guard other fields
    IF (NEW.order_start_date IS DISTINCT FROM OLD.order_start_date)
        OR (NEW.order_number IS DISTINCT FROM OLD.order_number)
        OR (NEW.style_number IS DISTINCT FROM OLD.style_number)
        OR (NEW.customer_name IS DISTINCT FROM OLD.customer_name) THEN
        RAISE EXCEPTION '仅允许更新 note 和 order_finish_date';
    END IF;
    NEW.updated_at := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_guard_orders_update ON production.orders;
CREATE TRIGGER trg_guard_orders_update
BEFORE UPDATE ON production.orders
FOR EACH ROW
EXECUTE FUNCTION production.guard_orders_update();

-- Keep order_items immutable
CREATE OR REPLACE FUNCTION production.prevent_order_items_update()
RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION '订单项不可修改';
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_prevent_update_order_items ON production.order_items;
CREATE TRIGGER trg_prevent_update_order_items
BEFORE UPDATE ON production.order_items
FOR EACH ROW
EXECUTE FUNCTION production.prevent_order_items_update();

-- Plans (must be based on an order)
CREATE TABLE IF NOT EXISTS production.plans (
    plan_id SERIAL PRIMARY KEY,
    plan_name VARCHAR(255) NOT NULL,
    order_id INT NOT NULL REFERENCES production.orders(order_id) ON DELETE CASCADE,
    note TEXT,
    planned_publish_date TIMESTAMP,                             -- when plan is published
    planned_finish_date TIMESTAMP,                              -- when plan is finished
    status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending','in_progress','completed')),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,    -- when plan is created in CUTRIX system
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP     -- when plan is updated in CUTRIX system
);

-- Cutting layouts
CREATE TABLE IF NOT EXISTS production.cutting_layouts (
    layout_id SERIAL PRIMARY KEY,
    plan_id INT NOT NULL REFERENCES production.plans(plan_id) ON DELETE CASCADE,
    layout_name VARCHAR(100) NOT NULL,
    note TEXT,
);

-- Layout size ratios
CREATE TABLE IF NOT EXISTS production.layout_size_ratios (
    ratio_id SERIAL PRIMARY KEY,
    layout_id INT NOT NULL REFERENCES production.cutting_layouts(layout_id) ON DELETE CASCADE,
    size VARCHAR(50) NOT NULL,
    ratio INT NOT NULL CHECK (ratio >= 0),
    UNIQUE(layout_id, size)
);

-- Tasks (拉布)
CREATE TABLE IF NOT EXISTS production.tasks (
    task_id SERIAL PRIMARY KEY,
    layout_id INT NOT NULL REFERENCES production.cutting_layouts(layout_id) ON DELETE CASCADE,
    color VARCHAR(50) NOT NULL,
    planned_layers INT NOT NULL CHECK (planned_layers > 0),
    completed_layers INT DEFAULT 0,
    status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed')),
);

-- Logs (worker submissions)
CREATE TABLE IF NOT EXISTS production.logs (
    log_id SERIAL PRIMARY KEY,
    task_id INT NOT NULL REFERENCES production.tasks(task_id) ON DELETE CASCADE,
    worker_id INT REFERENCES public.users(user_id) ON DELETE SET NULL,
    worker_name VARCHAR(50), -- redundant to preserve history when worker deleted
    layers_completed INT NOT NULL CHECK (layers_completed > 0),
    log_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    notes TEXT,
    voided BOOLEAN NOT NULL DEFAULT false,
    void_reason TEXT,
    voided_at TIMESTAMP,
    voided_by INT REFERENCES public.users(user_id) ON DELETE SET NULL,
    voided_by_name VARCHAR(50)
);

-- Trigger functions (schema-qualified)
CREATE OR REPLACE FUNCTION production.update_completed_layers()
RETURNS TRIGGER AS $$
BEGIN
    -- Ensure positive layers
    IF NEW.layers_completed <= 0 THEN
        RAISE EXCEPTION '完成层数必须大于0';
    END IF;

    -- Atomically update completed_layers and status in one statement to avoid race conditions
    UPDATE production.tasks
    SET 
        completed_layers = completed_layers + NEW.layers_completed,
        status = CASE
            WHEN planned_layers IS NOT NULL AND completed_layers + NEW.layers_completed >= planned_layers THEN 'completed'
            WHEN completed_layers + NEW.layers_completed > 0 THEN 'in_progress'
            ELSE 'pending'
        END
    WHERE task_id = NEW.task_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION production.set_log_worker_name()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.worker_name IS NULL THEN
        SELECT name INTO NEW.worker_name FROM public.users WHERE user_id = NEW.worker_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers on logs
DROP TRIGGER IF EXISTS trg_before_log_insert_set_name ON production.logs;
CREATE TRIGGER trg_before_log_insert_set_name
BEFORE INSERT ON production.logs
FOR EACH ROW
EXECUTE FUNCTION production.set_log_worker_name();

DROP TRIGGER IF EXISTS trg_after_log_insert ON production.logs;
CREATE TRIGGER trg_after_log_insert
AFTER INSERT ON production.logs
FOR EACH ROW
EXECUTE FUNCTION production.update_completed_layers();

-- Seed data (optional, idempotent)
-- Migrate to users table
INSERT INTO public.users (name, password_hash, role) VALUES
('admin', '$2a$12$gwwSt9.uKHrxcCffsmgc0OvsdcRa1qldHE4bR/XrKNlYMK6IRyGty', 'admin'),
('manager', '$2a$12$kFFQ9IF1WV3Ky4VefgLFfOJl.bD1Ef/9bQC/7Ghc.IlFRRCjosya2', 'manager'),
('张三', '$2a$12$gwwSt9.uKHrxcCffsmgc0OvsdcRa1qldHE4bR/XrKNlYMK6IRyGty', 'worker'),
('王五', '$2a$12$gwwSt9.uKHrxcCffsmgc0OvsdcRa1qldHE4bR/XrKNlYMK6IRyGty', 'pattern_maker')
ON CONFLICT (name) DO NOTHING;

INSERT INTO production.orders (order_number, style_number, customer_name, order_start_date, order_finish_date, note) VALUES 
('ORD-2024-001', 'BEE3TS111', '客户A', '2024-01-15', '2024-02-15', NULL),
('ORD-2024-002', 'BEE3TS112', '客户B', '2024-01-16', '2024-02-20', NULL),
('ORD-2024-003', 'BEE3TS113', '客户C', '2024-01-17', '2024-02-25', NULL)
ON CONFLICT (order_number) DO NOTHING;

-- Corrections: apply delta on void/unvoid of logs
CREATE OR REPLACE FUNCTION production.apply_log_void_delta()
RETURNS TRIGGER AS $$
DECLARE
    planned INT;
    completed INT;
    new_completed INT;
BEGIN
    SELECT planned_layers, completed_layers INTO planned, completed
    FROM production.tasks
    WHERE task_id = NEW.task_id;

    -- 仅在 voided 标志变化时处理
    IF NEW.voided = TRUE AND (OLD.voided IS DISTINCT FROM TRUE) THEN
        new_completed := completed - OLD.layers_completed;
        IF new_completed < 0 THEN
            RAISE EXCEPTION '作废后完成层数不能小于0 (当前: %, 作废层数: %, 任务: %)', completed, OLD.layers_completed, NEW.task_id;
        END IF;
        UPDATE production.tasks
        SET
            completed_layers = new_completed,
            status = CASE
                WHEN planned IS NOT NULL AND new_completed >= planned THEN 'completed'
                WHEN new_completed > 0 THEN 'in_progress'
                ELSE 'pending'
            END,
            updated_at = CURRENT_TIMESTAMP
        WHERE task_id = NEW.task_id;

    ELSIF NEW.voided = FALSE AND (OLD.voided IS DISTINCT FROM FALSE) THEN
        new_completed := completed + OLD.layers_completed;
        UPDATE production.tasks
        SET
            completed_layers = new_completed,
            status = CASE
                WHEN planned IS NOT NULL AND new_completed >= planned THEN 'completed'
                WHEN new_completed > 0 THEN 'in_progress'
                ELSE 'pending'
            END,
            updated_at = CURRENT_TIMESTAMP
        WHERE task_id = NEW.task_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Fill voided_by_name before applying deltas
CREATE OR REPLACE FUNCTION production.set_voided_by_name()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.voided = TRUE AND (OLD.voided IS DISTINCT FROM TRUE) THEN
        IF NEW.voided_by_name IS NULL AND NEW.voided_by IS NOT NULL THEN
            SELECT name INTO NEW.voided_by_name FROM public.users WHERE user_id = NEW.voided_by;
        END IF;
        IF NEW.voided_at IS NULL THEN
            NEW.voided_at := CURRENT_TIMESTAMP;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_before_log_update_set_voided_by_name ON production.logs;
CREATE TRIGGER trg_before_log_update_set_voided_by_name
BEFORE UPDATE OF voided ON production.logs
FOR EACH ROW
EXECUTE FUNCTION production.set_voided_by_name();

-- Trigger on logs to apply delta when void status changes
DROP TRIGGER IF EXISTS trg_after_log_update_void ON production.logs;
CREATE TRIGGER trg_after_log_update_void
AFTER UPDATE OF voided ON production.logs
FOR EACH ROW
EXECUTE FUNCTION production.apply_log_void_delta();

-- Enforce: layout size must be subset of order sizes
CREATE OR REPLACE FUNCTION production.ensure_layout_size_in_order()
RETURNS TRIGGER AS $$
DECLARE
    v_order_id INT;
BEGIN
    SELECT p.order_id INTO v_order_id
    FROM production.cutting_layouts l
    JOIN production.plans p ON p.plan_id = l.plan_id
    WHERE l.layout_id = NEW.layout_id;

    IF v_order_id IS NULL THEN
        RAISE EXCEPTION '布局未关联到计划: %', NEW.layout_id;
    END IF;

    IF NOT EXISTS (
        SELECT 1
        FROM production.order_items oi
        WHERE oi.order_id = v_order_id AND oi.size = NEW.size
    ) THEN
        RAISE EXCEPTION '布局尺码 % 必须属于订单的尺码集合', NEW.size;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_guard_layout_size ON production.layout_size_ratios;
CREATE TRIGGER trg_guard_layout_size
BEFORE INSERT OR UPDATE ON production.layout_size_ratios
FOR EACH ROW
EXECUTE FUNCTION production.ensure_layout_size_in_order();

-- Enforce: task color must appear in order items
CREATE OR REPLACE FUNCTION production.ensure_task_color_in_order()
RETURNS TRIGGER AS $$
DECLARE
    v_order_id INT;
BEGIN
    SELECT p.order_id INTO v_order_id
    FROM production.cutting_layouts l
    JOIN production.plans p ON p.plan_id = l.plan_id
    WHERE l.layout_id = NEW.layout_id;

    IF v_order_id IS NULL THEN
        RAISE EXCEPTION '任务未关联到计划: %', NEW.layout_id;
    END IF;

    IF NOT EXISTS (
        SELECT 1
        FROM production.order_items oi
        WHERE oi.order_id = v_order_id AND oi.color = NEW.color
    ) THEN
        RAISE EXCEPTION '任务颜色 % 必须出现在订单项中', NEW.color;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_guard_task_color ON production.tasks;
CREATE TRIGGER trg_guard_task_color
BEFORE INSERT OR UPDATE ON production.tasks
FOR EACH ROW
EXECUTE FUNCTION production.ensure_task_color_in_order();

-- Helpers: compute plan totals
CREATE OR REPLACE FUNCTION production.plan_planned_units(p_plan_id INT)
RETURNS INT AS $$
DECLARE
    v_total INT;
BEGIN
    SELECT COALESCE(SUM(t.planned_layers * r.units_per_layer), 0) INTO v_total
    FROM production.tasks t
    JOIN production.cutting_layouts l ON l.layout_id = t.layout_id
    LEFT JOIN (
        SELECT layout_id, SUM(ratio) AS units_per_layer
        FROM production.layout_size_ratios
        GROUP BY layout_id
    ) r ON r.layout_id = t.layout_id
    WHERE l.plan_id = p_plan_id;
    RETURN COALESCE(v_total, 0);
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION production.plan_completed_units(p_plan_id INT)
RETURNS INT AS $$
DECLARE
    v_total INT;
BEGIN
    SELECT COALESCE(SUM(t.completed_layers * r.units_per_layer), 0) INTO v_total
    FROM production.tasks t
    JOIN production.cutting_layouts l ON l.layout_id = t.layout_id
    LEFT JOIN (
        SELECT layout_id, SUM(ratio) AS units_per_layer
        FROM production.layout_size_ratios
        GROUP BY layout_id
    ) r ON r.layout_id = t.layout_id
    WHERE l.plan_id = p_plan_id;
    RETURN COALESCE(v_total, 0);
END;
$$ LANGUAGE plpgsql STABLE;

-- Update plan progress & finish date
CREATE OR REPLACE FUNCTION production.update_plan_progress(p_plan_id INT)
RETURNS VOID AS $$
DECLARE
    v_planned INT;
    v_completed INT;
BEGIN
    v_planned := production.plan_planned_units(p_plan_id);
    v_completed := production.plan_completed_units(p_plan_id);

    UPDATE production.plans
    SET
        status = CASE
            WHEN v_planned > 0 AND v_completed >= v_planned THEN 'completed'
            WHEN v_completed > 0 THEN 'in_progress'
            ELSE status
        END,
        planned_finish_date = CASE
            WHEN v_planned > 0 AND v_completed >= v_planned THEN COALESCE(planned_finish_date, CURRENT_TIMESTAMP)
            ELSE planned_finish_date
        END,
        updated_at = CURRENT_TIMESTAMP
    WHERE plan_id = p_plan_id;
END;
$$ LANGUAGE plpgsql;

-- Trigger: recalc plan progress on task changes
CREATE OR REPLACE FUNCTION production.update_plan_on_task_change()
RETURNS TRIGGER AS $$
DECLARE
    v_plan_id INT;
    v_layout_id INT;
BEGIN
    v_layout_id := COALESCE(NEW.layout_id, OLD.layout_id);
    SELECT plan_id INTO v_plan_id FROM production.cutting_layouts WHERE layout_id = v_layout_id;
    IF v_plan_id IS NOT NULL THEN
        PERFORM production.update_plan_progress(v_plan_id);
    END IF;
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_after_task_change_update_plan ON production.tasks;
CREATE TRIGGER trg_after_task_change_update_plan
AFTER INSERT OR UPDATE OR DELETE ON production.tasks
FOR EACH ROW
EXECUTE FUNCTION production.update_plan_on_task_change();

-- Trigger: recalc plan progress on ratio changes
CREATE OR REPLACE FUNCTION production.update_plan_on_ratio_change()
RETURNS TRIGGER AS $$
DECLARE
    v_plan_id INT;
    v_layout_id INT;
BEGIN
    v_layout_id := COALESCE(NEW.layout_id, OLD.layout_id);
    SELECT plan_id INTO v_plan_id FROM production.cutting_layouts WHERE layout_id = v_layout_id;
    IF v_plan_id IS NOT NULL THEN
        PERFORM production.update_plan_progress(v_plan_id);
    END IF;
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_after_ratio_change_update_plan ON production.layout_size_ratios;
CREATE TRIGGER trg_after_ratio_change_update_plan
AFTER INSERT OR UPDATE OR DELETE ON production.layout_size_ratios
FOR EACH ROW
EXECUTE FUNCTION production.update_plan_on_ratio_change();

-- Guard: ensure per-layout ratios sum is positive (>0)
CREATE OR REPLACE FUNCTION production.guard_layout_ratios_positive()
RETURNS TRIGGER AS $$
DECLARE
    v_sum INT;
BEGIN
    IF TG_OP = 'UPDATE' THEN
        -- Check old layout_id (row moved or value changed)
        SELECT COALESCE(SUM(ratio),0) INTO v_sum FROM production.layout_size_ratios WHERE layout_id = OLD.layout_id;
        IF v_sum <= 0 THEN
            RAISE EXCEPTION '布局 % 的尺码比例总和必须大于0', OLD.layout_id;
        END IF;
        -- Check new layout_id
        SELECT COALESCE(SUM(ratio),0) INTO v_sum FROM production.layout_size_ratios WHERE layout_id = NEW.layout_id;
        IF v_sum <= 0 THEN
            RAISE EXCEPTION '布局 % 的尺码比例总和必须大于0', NEW.layout_id;
        END IF;
    ELSE
        SELECT COALESCE(SUM(ratio),0) INTO v_sum FROM production.layout_size_ratios WHERE layout_id = COALESCE(NEW.layout_id, OLD.layout_id);
        IF v_sum <= 0 THEN
            RAISE EXCEPTION '布局 % 的尺码比例总和必须大于0', COALESCE(NEW.layout_id, OLD.layout_id);
        END IF;
    END IF;
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_after_ratio_change_guard_positive ON production.layout_size_ratios;
CREATE TRIGGER trg_after_ratio_change_guard_positive
AFTER INSERT OR UPDATE OR DELETE ON production.layout_size_ratios
FOR EACH ROW
EXECUTE FUNCTION production.guard_layout_ratios_positive();

-- Trigger: recalc plan progress on layout changes
CREATE OR REPLACE FUNCTION production.update_plan_on_layout_change()
RETURNS TRIGGER AS $$
DECLARE
    v_plan_id INT;
BEGIN
    v_plan_id := COALESCE(NEW.plan_id, OLD.plan_id);
    IF v_plan_id IS NOT NULL THEN
        PERFORM production.update_plan_progress(v_plan_id);
    END IF;
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_after_layout_change_update_plan ON production.cutting_layouts;
CREATE TRIGGER trg_after_layout_change_update_plan
AFTER INSERT OR UPDATE OR DELETE ON production.cutting_layouts
FOR EACH ROW
EXECUTE FUNCTION production.update_plan_on_layout_change();

-- Touch plans.updated_at automatically on any update
CREATE OR REPLACE FUNCTION production.touch_plan_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_touch_plan_updated ON production.plans;
CREATE TRIGGER trg_touch_plan_updated
BEFORE UPDATE ON production.plans
FOR EACH ROW
EXECUTE FUNCTION production.touch_plan_updated_at();

-- Guard publish: status transition sets publish date and requires positive planned total
CREATE OR REPLACE FUNCTION production.guard_plan_publish()
RETURNS TRIGGER AS $$
DECLARE
    v_planned INT;
BEGIN
    IF NEW.status = 'in_progress' AND (OLD.status IS DISTINCT FROM 'in_progress') THEN
        IF NEW.planned_publish_date IS NULL THEN
            NEW.planned_publish_date := CURRENT_TIMESTAMP;
        END IF;
        v_planned := production.plan_planned_units(OLD.plan_id);
        IF v_planned <= 0 THEN
            RAISE EXCEPTION '发布失败：计划总数必须为正数';
        END IF;
        NEW.updated_at := CURRENT_TIMESTAMP;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_guard_plan_publish ON production.plans;
CREATE TRIGGER trg_guard_plan_publish
BEFORE UPDATE OF status ON production.plans
FOR EACH ROW
EXECUTE FUNCTION production.guard_plan_publish();

COMMIT;